/// Represents a reference to an object in a P4 program.
class StateVariable : Expression {
#noconstructor
#nooperator==
#emit
/// The member of a StateVariable. Requires a type and a name.
    class VariableMember {
     public:
        /// The type of the variable item.
        const IR::Type *type;

        /// The name of the variable item.
        cstring name;

        VariableMember(const VariableMember &) = default;
        VariableMember(VariableMember &&) = default;
        VariableMember &operator=(const VariableMember &) = default;
        VariableMember &operator=(VariableMember &&) = default;
        ~VariableMember() = default;

        /// Construct with type and cstring.
        VariableMember(const IR::Type *type, cstring name);  // NOLINT(runtime/explicit)
    };
 private:
    /// The wrapped members.
    std::deque<VariableMember> members;

    /// A constructor for an anonymous, untyped state variable without type information.
    StateVariable(std::initializer_list<cstring> untypedMembers);

 public:
    StateVariable(const StateVariable &) = default;
    StateVariable(StateVariable &&) = default;
    StateVariable &operator=(const StateVariable &) = default;
    StateVariable &operator=(StateVariable &&) = default;
    ~StateVariable() override = default;

    /// Derives a StateVariable from a member by unraveling the member.
    /// The type of the StateVariable is the type of the member, and with that the last element.
    explicit StateVariable(const IR::Member &member);

    /// Derives a StateVariable from a PathExpression, which is just the path contained within the
    /// expression. The type of the StateVariable is the type of the path.
    explicit StateVariable(const IR::PathExpression &path);

    /// Derives a StateVariable from a deque of members.
    /// If the list is not empty the type of the StateVariable is the last element in the deque.
    explicit StateVariable(const Util::SourceInfo &srcInfo, std::deque<VariableMember> members);

    /// Derives a StateVariable from a deque of members.
    /// If the list is not empty the type of the StateVariable is the last element in the deque.
    explicit StateVariable(std::deque<VariableMember> members);

    /// A completely untyped StateVariable.
    /// Useful if you need to initialize an anonymous variable which is typed later.
    // NOLINTNEXTLINE
    [[nodiscard]] static StateVariable UntypedStateVariable(
        std::initializer_list<cstring> untypedMembers);

    /// @returns the list of members contained in this StateVariable.
    [[nodiscard]] const std::deque<VariableMember> &getMembers() const;

    /// @returns the element at index @param n.
    [[nodiscard]] const StateVariable::VariableMember &at(size_t n) const;

    /// @returns the size of the state variable in terms of members.
    [[nodiscard]] size_t size() const;

    /// @returns the first member (from the right).
    [[nodiscard]] const StateVariable::VariableMember &front() const;

    /// @returns the last member (from the right).
    [[nodiscard]] const StateVariable::VariableMember &back() const;

    /// Prepend a member to the StateVariable in place.
    void popFrontInPlace();

    /// Pops the first member (from the right) from the StateVariable and then @returns a new
    /// variable.
    [[nodiscard]] StateVariable popFront() const;

    /// Append a member to the StateVariable in place. Updates the type of the member.
    void popBackInPlace();

    /// Pops the last member (from the right) from the StateVariable and then @returns a new
    /// variable.
    [[nodiscard]] StateVariable popBack() const;

    /// Append a member to the StateVariable in place. Updates the type of the member.
    void appendInPlace(VariableMember item);

    /// Append a member to the StateVariable. @returns a new variable.
    [[nodiscard]] StateVariable append(VariableMember item) const;

    /// Prepend a member to the StateVariable in place.
    void prependInPlace(VariableMember item);

    /// Prepend a member to the StateVariable. @returns a new variable.
    [[nodiscard]] StateVariable prepend(VariableMember item) const;

    /// @returns a StateVariable which contains a subset of the parent variable.
    /// TODO: Use a std::span once we have C++20.
    [[nodiscard]] StateVariable getSlice(int64_t lo, int64_t hi) const;
#end

    /// Implements comparisons so that StateVariables can be used as map keys.
    bool operator==(const StateVariable &other) const override;

    /// Implements comparisons so that StateVariables can be used as map keys.
    equiv {
    // We use a custom compare function.
    auto memberSize = members.size();
    auto otherMemberSize = members.size();
    if (memberSize != otherMemberSize) {
        return false;
    }
    for (size_t idx = 0; idx < memberSize; ++idx) {
        auto member = members.at(idx);
        auto otherMember = a.members.at(idx);
        if (member.name != otherMember.name || member.type->equiv(*otherMember.type)) {
            return false;
        }
    }
    return true;
    }

    /// Implements comparisons so that StateVariables can be used as map keys.
    bool operator<(const StateVariable &other) const;

    cstring toString() const override;

    void dbprint(std::ostream &out) const override;
};


/// Signifies that a particular expression is tainted.
/// This tainted expression must be resolved explicitly.
class TaintExpression : Expression {
    toString { return "TaintedExpression(" + type->toString() + ")"; }

    dbprint { out << "TaintedExpression(" << type << ")"; }
}

/// This type replaces Type_Varbits and can store information about the current size
class Extracted_Varbits : Type_Bits {
    /// The assigned size of this varbit (assigned by extract calls).
    int assignedSize;

    /// Returns the current width this variable bit type has.
    int width_bits() const override { return assignedSize; }

    equiv {
        // Ignore the current size and only check for equivalence of the assigned size.
        return size == a.size;
    }

    operator== {
        // Ignore the current size and only check for equivalence of the assigned size.
        return size == a.size;
    }

    cstring baseName() const { return "SizedVarbit"; }

    toString {
        return baseName() + "<" + Util::toString(size) + ">" + "<" + Util::toString(assignedSize) +
               ">";
    }

    dbprint { out << toString(); }
}

/// Defines a concolic variable that may be part of expressions.
/// This variable must later be resolved and is converted in a symbolic expression.
class ConcolicVariable : Expression {
    /// The name of the concolic method that this variable targets.
    cstring concolicMethodName;

    /// Arguments to the concolic method.
    Vector<Argument> arguments;

    /// The unique identifier of the source the produces this concolic variable.
    int srcIdentifier;

    /// Some identifiers produce multiple concolic variables. This ID keeps track of the offsets.
    int concolicId;

    /// Nodes that are associated with this concolic variable. This may be declarations.
    optional inline IndexedVector<Node> associatedNodes;

    /// This is the member representation of this concolic variable.
    Member concolicMember = nullptr;

    toString {
        cstring argumentStr;
        cstring sep = "";
        for (auto arg : *arguments) {
            argumentStr += sep + arg->toString();
            sep = ", ";
        }
        return "Concolic_" + concolicMethodName + "_" + srcIdentifier + "_" + concolicId + "(" +
               argumentStr + ")";
    }

    dbprint {
        out << "Concolic_" << concolicMethodName << "_" << srcIdentifier << "_" << concolicId << "("
            << arguments << ")";
    }

    visit_children { v.visit(type, "type"); }

    ConcolicVariable {
        std::stringstream varName;
        varName << concolicMethodName << "_" << srcIdentifier;
        concolicMember =
            new Member(srcInfo, type, new PathExpression(new Path(varName.str().c_str())),
                       std::to_string(concolicId).c_str());
    }
}
